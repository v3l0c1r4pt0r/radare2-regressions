NAME=a2f jmp after ret
FILE=malloc://512
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
a2f
afl~?
EOF
RUN

NAME=a2f jmp after ret - _size (symsize)
FILE=malloc://512
EXPECT=<<EOF
1
60
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
a2f
afl~?
afl~[2]
EOF
RUN

NAME=a2f jmp after ret - realsize (bbs_sum)
FILE=malloc://512
EXPECT=<<EOF
1
60
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=64
wx b8010000004839ca7f26b8ffffffff4839ca7c1c498b4838498b5138b8010000004839ca7f0ab8ffffffff4839ca7d025dc34883c7684883c6685dc3
a2f
afl~?
afl~[2]
EOF
RUN

NAME=a2f 8 bbs 4 ret and some jumps
FILE=malloc://512
EXPECT=<<EOF
0x00000000 0x00000004 00:0000 4 j 0x00000009 f 0x00000004
0x00000004 0x00000008 00:0000 4 j 0x0000000d f 0x00000008
0x00000008 0x00000009 00:0000 1
0x00000009 0x0000000d 00:0000 4 j 0x0000000e
0x0000000d 0x0000000e 00:0000 1
0x0000000e 0x00000012 00:0000 4 j 0x00000013 f 0x00000012
0x00000012 0x00000013 00:0000 1
0x00000013 0x00000019 00:0000 6
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=32
wx 85c0740585c07405c385c0eb01c385c07401c3b8efbeaddec3
a2f
afb
EOF
RUN

NAME=a2f 3bbs with entry in the middle of the function
FILE=malloc://512
EXPECT=<<EOF
0x00000000 0x0000000a 00:0000 10 j 0x0000000a
0x0000000a 0x0000000e 00:0000 4 j 0x00000000 f 0x0000000e
0x0000000e 0x00000014 00:0000 6
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=32
wx 31c031c983c10183c10285c975f231c931c040c3
s 0xa
a2f
afb
EOF
RUN

NAME=a2f 6 bbs with entry at the end of the function
FILE=malloc://512
EXPECT=<<EOF
0x00000000 0x0000000a 00:0000 10 j 0x00000012 f 0x0000000a
0x0000000a 0x00000012 00:0000 8 j 0x00000012
0x00000012 0x0000001c 00:0000 10 j 0x00000000 f 0x0000001c
0x0000001c 0x00000026 00:0000 10 j 0x00000028 f 0x00000026
0x00000026 0x00000028 00:0000 2 j 0x00000000
0x00000028 0x0000002b 00:0000 3
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e asm.bits=32
wx 31c083c00183e801750831c083e80183c00131c983c10183e90175e431d283ea0183c2017402ebd831c0c3
s 0x26
a2f
afb
EOF
RUN

NAME=a2f cjmp
FILE=malloc://0x5000
EXPECT=<<EOF
0x00000000 0x00000004 00:0000 4 j 0x00000005 f 0x00000004
0x00000004 0x00000005 00:0000 1 j 0x00000005
0x00000005 0x00000006 00:0000 1
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e io.cache=true
e asm.bits=32
wx 31c0740140c3
a2f
afb
EOF
RUN

NAME=aaa with axt
FILE=../bins/anal/keygen.exe
EXPECT=<<EOF
(nofunc) 0x4bfe53 [DATA] mov edx, 0x4bffb0
EOF
CMDS=<<EOF
aaa
axt 0x4bffb0
EOF
RUN

NAME=aaa with maxbbsz
FILE=../bins/anal/flare_notepad.ex
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
e anal.bb.maxsize = 2048
aaa
pdf~ret?
EOF
RUN

NAME=aaa with avra
FILE=../bins/elf/class_test
EXPECT=<<EOF
VMI Type Info at 0x08048f4c:
  Reference to RTTI's type class: 0x0804b140
  Reference to type's name: 0x08048f6c
  Type Name: Bat
  Flags: 0x0
  Count of base classes: 0x2
      Base class type descriptor address: 0x08048f74
      Base class flags: 0x2
      Base class type descriptor address: 0x08048fac
      Base class flags: 0x402

VMI Type Info at 0x08048f4c:
  Reference to RTTI's type class: 0x0804b140
  Reference to type's name: 0x08048f6c
  Type Name: Bat
  Flags: 0x0
  Count of base classes: 0x2
      Base class type descriptor address: 0x08048f74
      Base class flags: 0x2
      Base class type descriptor address: 0x08048fac
      Base class flags: 0x402

Type Info at 0x08048f74:
  Reference to RTTI's type class: 0x0804b048
  Reference to type's name: 0x08048f7c
  Type Name: Bird

SI Type Info at 0x08048f84:
  Reference to RTTI's type class: 0x0804b114
  Reference to type's name: 0x08048f90
  Type Name: Dog
  Reference to parent's type name: 0x08048fac

SI Type Info at 0x08048f98:
  Reference to RTTI's type class: 0x0804b114
  Reference to type's name: 0x08048fa4
  Type Name: Cat
  Reference to parent's type name: 0x08048fac

Type Info at 0x08048fac:
  Reference to RTTI's type class: 0x0804b048
  Reference to type's name: 0x08048fb4
  Type Name: Mammal

EOF
CMDS=<<EOF
aaa
avra
EOF
RUN

NAME=aac on mips be
FILE=../bins/elf/analysis/mipsbe-busybox
EXPECT=<<EOF
1269
EOF
CMDS=<<EOF
aac
afl~?
EOF
RUN

NAME=raw aac with maps (less because of wrong map address)
FILE=../bins/elf/analysis/mipsbe-busybox
ARGS=-n -m 0x80000 -a mips -b32 -e cfg.bigendian=true
EXPECT=<<EOF
4
EOF
CMDS=<<EOF
aac
afl~?
EOF
RUN

NAME=raw aac (using a PIC bin)
BROKEN=1
FILE=../bins/elf/libmagic.so
EXPECT=<<EOF
202
EOF
CMDS=<<EOF
aac
afl~?
EOF
RUN

NAME=raw aac with maps (using a PIC bin)
BROKEN=1
FILE=../bins/elf/libmagic.so
ARGS=-n -m 0x80000 -a arm -b 16 -e cfg.bigendian=false
EXPECT=<<EOF
96
EOF
CMDS=<<EOF
aac
e search.in=io.maps
afl~?
EOF
RUN

NAME=aav without vinfun
FILE=../bins/elf/analysis/mipsbe-busybox
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
af @ 0x0040dea4
e anal.vinfun=false
aav
pd 1 @ 0x0040decc~?andi
EOF
RUN

NAME=aav with vinfun
FILE=../bins/elf/analysis/mipsbe-busybox
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
af @ 0x0040dea4
e anal.vinfun=true
aav
pd 1 @ 0x0040decc~?dword
EOF
RUN

NAME=aav thumb detection
FILE=../bins/firmware/armthumb.bin
ARGS=-aarm -b32
EXPECT=<<EOF
0x0000000d 4 aav.0x0000000d
EOF
CMDS=<<EOF
aav
f
EOF
RUN

NAME=arj x86 32 bits
FILE=malloc://0x100
EXPECT='{"oeax":0,"eax":0,"ebx":0,"ecx":0,"edx":0,"esi":0,"edi":0,"esp":0,"ebp":0,"eip":0,"eflags":0}
'
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e asm.bits=32
arj
EOF
RUN

NAME=arj x86 16 bits
FILE=malloc://0x100
EXPECT='{"ip":0,"ax":0,"bx":0,"cx":0,"dx":0,"sp":0,"bp":0,"si":0,"di":0,"flags":0}
'
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e asm.bits=16
arj
EOF
RUN

NAME=sym is not fcn
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
EOF
CMDS=<<EOF
aa > /dev/null
afl~sym.__mh_execute_header[0]
EOF
RUN

NAME=af x86-32
FILE=malloc://1024
EXPECT=<<EOF
6
EOF
CMDS=<<EOF
e anal.hasnext=0
e anal.eobjmp=false
e asm.arch=x86
e asm.bits=32
wx 6a00 4889e5 c3
af
afl~[2]
EOF
RUN

NAME=af x86-32 ujmp eobjmp=true
FILE=malloc://1024
EXPECT=<<EOF
11
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e anal.eobjmp=true
e asm.bits=32
wx 6a00 4889e5 ff25f8120000 ff25f8120000ffe0c3
af
afl~[2]
EOF
RUN

NAME=af x86-32 ujmp eobjmp=false
FILE=malloc://1024
EXPECT=<<EOF
11
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e anal.eobjmp=false
e asm.bits=32
wx 6a00 4889e5 ff25f8120000 ff25f8120000ffe0c3
af
afl~[2]
EOF
RUN

NAME=af bug
FILE=malloc://1024
EXPECT=<<EOF
push 0
dec eax
mov ebp, esp
dec eax
and esp, 0xfffffff0
dec eax
mov edi, dword [ebp + 8]
dec eax
lea esi, [ebp + 0x10]
mov edx, edi
add edx, 1
shl edx, 3
dec eax
add edx, esi
dec eax
mov ecx, edx
jmp 0x25
dec eax
add ecx, 8
dec eax
cmp dword [ecx], 0
jne 0x21
dec eax
add ecx, 8
call 0xf8c
mov edi, eax
call 0x3956
ret
EOF
CMDS=<<EOF
e anal.hasnext=0
e asm.arch=x86
e anal.eobjmp=false
e asm.bits=32
wx 6a004889e54883e4f0488b7d08488d751089fa83c201c1e2034801f24889d1eb044883c1084883390075f64883c108e8580f000089c7e81b390000c3554889e5
s +0x40
wx 488d4768488d7e684889c6c9e9013a0000554889e54883c6684883c768c9e9ef390000554889e5534889f1488b5660488b4760488b583048395a307f1d7c2248
s -0x40
af
b 0x80
pIf
EOF
RUN

NAME=disasm bug
FILE=malloc://1024
EXPECT=<<EOF
push 0
dec eax
mov ebp, esp
dec eax
and esp, 0xfffffff0
dec eax
mov edi, dword [ebp + 8]
dec eax
lea esi, [ebp + 0x10]
mov edx, edi
add edx, 1
shl edx, 3
dec eax
add edx, esi
dec eax
mov ecx, edx
jmp 0x25
dec eax
add ecx, 8
dec eax
cmp dword [ecx], 0
jne 0x21
dec eax
add ecx, 8
call 0xf8c
mov edi, eax
call 0x3956
ret
EOF
CMDS=<<EOF
e anal.hasnext=0
e anal.eobjmp=false
e asm.arch=x86
e asm.bits=32
wx 6a004889e54883e4f0488b7d08488d751089fa83c201c1e2034801f24889d1eb044883c1084883390075f64883c108e8580f000089c7e81b390000c3554889e5
s+0x40
wx 488d4768488d7e684889c6c9e9013a0000554889e54883c6684883c768c9e9ef390000554889e5534889f1488b5660488b4760488b583048395a307f1d7c2248
s-0x40
b 0x100
af
pIf @0
EOF
RUN

NAME=call-convention
FILE=../bins/elf/analysis/x86-simple
EXPECT=<<EOF
call-convention: stdcall
EOF
CMDS=<<EOF
aa
s entry0
afc stdcall
afi~call-convention
EOF
RUN

NAME=function address
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f50
0x00001f00
EOF
CMDS=<<EOF
e anal.hasnext=0
aa
afo sym._foo
afo sym._bar
EOF
RUN

NAME=afr
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f00    4 73           sym._bar
0x00001f50    1 47           sym._foo
0x00001f80    1 41           sym._main
EOF
CMDS=<<EOF
e anal.hasnext=0
afr
afl
EOF
RUN

NAME=aF
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f80    1 41           sym._main
EOF
CMDS=<<EOF
e anal.hasnext=0
aF
afl
EOF
RUN

NAME=function prelude offsets
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f00
0x00001f50
0x00001f80
EOF
CMDS=<<EOF
s 0x1000
aap
afl~[0]
EOF
RUN

NAME=function preludes symbol names
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
0x00001f00    4 73           sym._bar
0x00001f50    1 47           sym._foo
0x00001f80    1 41           sym._main
EOF
CMDS=<<EOF
s 0x1000
aap
afl
EOF
RUN

NAME=af afF
FILE=malloc://1024
EXPECT=<<EOF
/ (fcn) fcn.test
\           0x00000000 (6 byte folded function)
EOF
CMDS=<<EOF
e anal.hasnext=0
e anal.eobjmp=false
e asm.arch=x86
e asm.bits=32
wx 6a004889e5c3
af test
afF
pd 1 @ fcn.test
EOF
RUN

NAME=af afF graph
FILE=malloc://1024
EXPECT=<<EOF
[0x00000000]> VV @ fcn.test (nodes 1 edges 0 zoom 100%) BB-NORM mouse:canvas-y mov-speed:5
.---------------------------.
|  0x0                      |
| / (fcn) fcn.test          |
| (6 byte folded function)  |
`---------------------------'
EOF
CMDS=<<EOF
e anal.hasnext=0
e anal.eobjmp=false
e asm.arch=x86
e asm.bits=32
wx 6a004889e5c3
af test
afF
agf
EOF
RUN

NAME=af-*
FILE=../bins/elf/analysis/main
EXPECT=<<EOF
EOF
CMDS=<<EOF
aa
af-*
afl
EOF
RUN

NAME=ahc
FILE=malloc://16
EXPECT=<<EOF
5
0x00000025
0x00000025
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
wx ebfe
ahs 5
ahc 0x25
ahf 0x25
ao 1~jump,fail,size[1]
EOF
RUN

NAME=ahi S
FILE=malloc://16
EXPECT=<<EOF
mov eax, exit()
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
e asm.os=linux
wx b801000000
ahi S
pi 1
EOF
RUN

NAME=iS. and iSj. implementation
FILE=../bins/anal/lab1B
EXPECT='Current section
Nm Paddr       Size Vaddr      Memsz Perms Checksum          Name
00 0x00000188    36 0x08048188    36 -r-- .note.gnu.build_id
Current section
Nm Paddr       Size Vaddr      Memsz Perms Checksum          Name
{"name":".plt","size":240,"vsize":240,"perm":"-r-x","paddr":1888,"vaddr":134514528}'
CMDS=<<EOF
s 0x188
iS.
s 0x08058000
iS.
s 0x760
iSj.
EOF
RUN

NAME=iE and iE. implementation
FILE=../bins/anal/lab1B
EXPECT='Num Paddr      Vaddr      Bind     Type Size Name
022 0x000009b7 0x080489b7 GLOBAL   FUNC  189 decrypt
{"name":"prog_timeout","demname":"","flagname":"sym.prog_timeout","ordinal":35,"bind":"GLOBAL","size":17,"type":"FUNC","vaddr":134515110,"paddr":2470}'
CMDS=<<EOF
s 0x080489b9
iE.
s 0x080489a6
s+5
isj.
EOF
RUN

NAME=address information
FILE=../bins/mach0/mach0-i386
EXPECT=<<EOF
exec
read
flag
flag
EOF
CMDS=<<EOF
s entry0
ai
s sym.__mh_execute_header
ai
EOF
RUN

NAME=af x86-32
FILE=malloc://16
EXPECT=<<EOF
15
address: 0x0
opcode: nop
mnemonic: nop
prefix: 0
id: 494
bytes: 90
refptr: 0
size: 1
sign: false
type: nop
cycles: 1
esil: ,
stack: null
family: cpu
stackop: null
90
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
wx 9090
ao 1~?
ao 1
p8 1
EOF
RUN

NAME=af x86-64
FILE=malloc://16
EXPECT=<<EOF
10
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=64
wx 662e0f1f840000000000
ao 1~size[1]
EOF
RUN

NAME=anal/fcn_name
FILE=../bins/elf/analysis/main-g
EXPECT=<<EOF
/ (fcn) sym.call_gmon_start 23
EOF
CMDS=<<EOF
s 0x0040042c
af
pd 1~sym.call_gmon_start:0
EOF
RUN

NAME=anal/fcn_subname
FILE=../bins/elf/analysis/main-g
EXPECT=<<EOF
name: sym.call_gmon_start
/ (fcn) sym.call_gmon_start 23
EOF
CMDS=<<EOF
s 0x0040042c
af
afi~name
pd 1~sym.call_gmon_start:0
EOF
RUN

NAME=anal/name
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
name: main
EOF
CMDS=<<EOF
af
afi~name
EOF
RUN

NAME=anal hasnext on main
FILE=../bins/elf/true32
EXPECT=<<EOF
size: 261
EOF
CMDS=<<EOF
e anal.hasnext=true
af@main
afi@main~size
EOF
RUN

NAME=anal without hasnext on main
FILE=../bins/elf/true32
EXPECT=<<EOF
size: 261
EOF
CMDS=<<EOF
e anal.hasnext=false
af@main
afi@main~size
EOF
RUN

NAME=ahe
FILE=malloc://512
EXPECT=<<EOF
15
esil: test
EOF
CMDS=<<EOF
e asm.bits=64
e asm.arch = x86
e anal.arch = x86
ao~?
ahe test
ao~esil
EOF
RUN

NAME=ahe2
FILE=malloc://512
EXPECT=<<EOF
esil: test
EOF
CMDS=<<EOF
ahe test
ao~^esil
EOF
RUN

NAME=ahe 33,rax,=
FILE=malloc://512
EXPECT=<<EOF
0x00000021
EOF
CMDS=<<EOF
wx 000000
ahe 33,rax,=
aes
dr?rax
EOF
RUN

NAME=delete memory format with Cf-
FILE=../bins/dmg/src/Hello
EXPECT=<<EOF
            0x00000000      57             push rdi
            0x00000000 format x {
0x00000000 = 0x6c726f57
} 1
temp_proj
            0x00000000      57             push rdi
temp_proj
            0x00000000      57             push rdi
EOF
CMDS=<<EOF
pd 1
Cf 1 x
pd 1
Ps temp_proj
Cf-
pd 1
Ps temp_proj
Po temp_proj
pd 1
EOF
RUN

NAME=ao cjmp
FILE=-
EXPECT=<<EOF
size: 2
jump: 0x0000001d
fail: 0x00000002
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
wx 761b
ao~jump,fail,size
EOF
RUN

NAME=aoj 31c0
FILE=-
EXPECT='[
  {
    "opcode": "xor eax, eax",
    "disasm": "xor eax, eax",
    "mnemonic": "xor",
    "esil": "eax,eax,^=,$z,zf,=,$p,pf,=,$s,sf,=,$0,cf,=,$0,of,=",
    "sign": false,
    "prefix": 0,
    "id": 334,
    "opex": {
      "operands": [
        {
          "size": 4,
          "rw": 3,
          "type": "reg",
          "value": "eax"
        },
        {
          "size": 4,
          "rw": 1,
          "type": "reg",
          "value": "eax"
        }
      ],
      "modrm": true
    },
    "addr": 0,
    "bytes": "31c0",
    "size": 2,
    "type": "xor",
    "scale": 0,
    "refptr": 0,
    "cycles": 1,
    "failcycles": 0,
    "delay": 0,
    "stackptr": 0,
    "family": "cpu"
  }
]
'
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
wx 31c0
aoj~{}
EOF
RUN

NAME=reflines offset
FILE=malloc://1023
CMDS=<<EXPECT
e asm.calls=false
e asm.bits=32
e asm.leahints=false
e asm.cpu=x86
e asm.arch=x86
e anal.cpu=x86
e scr.utf8=true
e asm.comments=false
e asm.bytes=false
e scr.color=false
wx 31c039d6724aeb72908db426000000008d7e0131d289e8f7f131d28944241c89f8f7f13944241c76678b93080200008b028b50143b5018736dc6020983c20189501489f031d201cef7f129d639f5762a8b8b8c05000085c975b683c6018b93080200008b028b50143b50187327c6022083c20139f589501477d68b44242c65330514000000753783c43c5b5e5f5dc39089feebc9c744240420000000890424e87cc9ffffeba6c744240409000000890424e86ac9ffff8b8b8c050000eb84e87d1001008db6000000008dbc270000000055575653e8f7f0ffff81c32b9d010083ec3c658b0d14000000894c242c31c98b6a0c8b720889e929f1c1e90285c9894c241c0f848100000039f50f84930000008b7a1801fdf7d721fd8b7a1089e9896a0c2b4a0489fd2b6a0439e97f718b7a0c31ed
aa > /dev/null
pd 38
EXPECT=<<RUN
‚îå (fcn) fcn.00000000 1645
‚îÇ           ; var int var_4h @ esp+0x4
‚îÇ           ; var int var_1ch @ esp+0x1c
‚îÇ           ; var int var_2ch @ esp+0x2c
‚îÇ           0x00000000      xor eax, eax
‚îÇ           0x00000002      cmp esi, edx
‚îÇ       ‚îå‚îÄ< 0x00000004      jb 0x50
‚îÇ      ‚îå‚îÄ‚îÄ< 0x00000006      jmp 0x7a
       ‚îÇ‚îÇ   0x00000008      nop
       ‚îÇ‚îÇ   0x00000009      lea esi, [esi]
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ> 0x00000010      lea edi, [esi + 1]
‚îÇ     ‚ïé‚îÇ‚îÇ   0x00000013      xor edx, edx
‚îÇ     ‚ïé‚îÇ‚îÇ   0x00000015      mov eax, ebp
‚îÇ     ‚ïé‚îÇ‚îÇ   0x00000017      div ecx
‚îÇ     ‚ïé‚îÇ‚îÇ   0x00000019      xor edx, edx
‚îÇ     ‚ïé‚îÇ‚îÇ   0x0000001b      mov dword [var_1ch], eax
‚îÇ     ‚ïé‚îÇ‚îÇ   0x0000001f      mov eax, edi
‚îÇ     ‚ïé‚îÇ‚îÇ   0x00000021      div ecx
‚îÇ     ‚ïé‚îÇ‚îÇ   0x00000023      cmp dword [var_1ch], eax
‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ< 0x00000027      jbe 0x90
‚îÇ    ‚îÇ‚ïé‚îÇ‚îÇ   0x00000029      mov edx, dword [ebx + 0x208]
‚îÇ    ‚îÇ‚ïé‚îÇ‚îÇ   0x0000002f      mov eax, dword [edx]
‚îÇ    ‚îÇ‚ïé‚îÇ‚îÇ   0x00000031      mov edx, dword [eax + 0x14]
‚îÇ    ‚îÇ‚ïé‚îÇ‚îÇ   0x00000034      cmp edx, dword [eax + 0x18]
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ< 0x00000037      jae 0xa6
‚îÇ   ‚îÇ‚îÇ‚ïé‚îÇ‚îÇ   0x00000039      mov byte [edx], 9
‚îÇ   ‚îÇ‚îÇ‚ïé‚îÇ‚îÇ   0x0000003c      add edx, 1
‚îÇ   ‚îÇ‚îÇ‚ïé‚îÇ‚îÇ   0x0000003f      mov dword [eax + 0x14], edx
‚îÇ   ‚îÇ‚îÇ‚ïé‚îÇ‚îÇ   0x00000042      mov eax, esi
‚îÇ   ‚îÇ‚îÇ‚ïé‚îÇ‚îÇ   0x00000044      xor edx, edx
‚îÇ   ‚îÇ‚îÇ‚ïé‚îÇ‚îÇ   0x00000046      add esi, ecx
‚îÇ   ‚îÇ‚îÇ‚ïé‚îÇ‚îÇ   0x00000048      div ecx
‚îÇ   ‚îÇ‚îÇ‚ïé‚îÇ‚îÇ   0x0000004a      sub esi, edx
‚îÇ   ‚îÇ‚îÇ‚ïé‚îÇ‚îÇ   0x0000004c      cmp ebp, esi
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ< 0x0000004e      jbe 0x7a
‚îÇ  ‚îÇ‚îÇ‚îÇ‚ïé‚îÇ‚îî‚îÄ> 0x00000050      mov ecx, dword [ebx + 0x58c]
‚îÇ  ‚îÇ‚îÇ‚îÇ‚ïé‚îÇ    0x00000056      test ecx, ecx
‚îÇ  ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ< 0x00000058      jne 0x10
‚îÇ  ‚îÇ‚îÇ‚îÇ ‚îÇ    0x0000005a      add esi, 1
‚îÇ  ‚îÇ‚îÇ‚îÇ ‚îÇ    0x0000005d      mov edx, dword [ebx + 0x208]
‚îÇ  ‚îÇ‚îÇ‚îÇ ‚îÇ    0x00000063      mov eax, dword [edx]
‚îÇ  ‚îÇ‚îÇ‚îÇ ‚îÇ    0x00000065      mov edx, dword [eax + 0x14]
RUN

NAME=reflines offset (ascii)
FILE=malloc://1023
CMDS=<<EXPECT
e asm.calls=false
e asm.bits=32
e asm.leahints=false
e asm.cpu=x86
e anal.cpu=x86
e asm.arch=x86
e asm.comments=false
e asm.bytes=false
e scr.utf8=false
e scr.color=false
wx 31c039d6724aeb72908db426000000008d7e0131d289e8f7f131d28944241c89f8f7f13944241c76678b93080200008b028b50143b5018736dc6020983c20189501489f031d201cef7f129d639f5762a8b8b8c05000085c975b683c6018b93080200008b028b50143b50187327c6022083c20139f589501477d68b44242c65330514000000753783c43c5b5e5f5dc39089feebc9c744240420000000890424e87cc9ffffeba6c744240409000000890424e86ac9ffff8b8b8c050000eb84e87d1001008db6000000008dbc270000000055575653e8f7f0ffff81c32b9d010083ec3c658b0d14000000894c242c31c98b6a0c8b720889e929f1c1e90285c9894c241c0f848100000039f50f84930000008b7a1801fdf7d721fd8b7a1089e9896a0c2b4a0489fd2b6a0439e97f718b7a0c31ed
aa >/dev/null
pd 38
EXPECT=<<RUN
/ (fcn) fcn.00000000 1645
|           ; var int var_4h @ esp+0x4
|           ; var int var_1ch @ esp+0x1c
|           ; var int var_2ch @ esp+0x2c
|           0x00000000      xor eax, eax
|           0x00000002      cmp esi, edx
|       ,=< 0x00000004      jb 0x50
|      ,==< 0x00000006      jmp 0x7a
       ||   0x00000008      nop
       ||   0x00000009      lea esi, [esi]
|     .---> 0x00000010      lea edi, [esi + 1]
|     :||   0x00000013      xor edx, edx
|     :||   0x00000015      mov eax, ebp
|     :||   0x00000017      div ecx
|     :||   0x00000019      xor edx, edx
|     :||   0x0000001b      mov dword [var_1ch], eax
|     :||   0x0000001f      mov eax, edi
|     :||   0x00000021      div ecx
|     :||   0x00000023      cmp dword [var_1ch], eax
|    ,====< 0x00000027      jbe 0x90
|    |:||   0x00000029      mov edx, dword [ebx + 0x208]
|    |:||   0x0000002f      mov eax, dword [edx]
|    |:||   0x00000031      mov edx, dword [eax + 0x14]
|    |:||   0x00000034      cmp edx, dword [eax + 0x18]
|   ,=====< 0x00000037      jae 0xa6
|   ||:||   0x00000039      mov byte [edx], 9
|   ||:||   0x0000003c      add edx, 1
|   ||:||   0x0000003f      mov dword [eax + 0x14], edx
|   ||:||   0x00000042      mov eax, esi
|   ||:||   0x00000044      xor edx, edx
|   ||:||   0x00000046      add esi, ecx
|   ||:||   0x00000048      div ecx
|   ||:||   0x0000004a      sub esi, edx
|   ||:||   0x0000004c      cmp ebp, esi
|  ,======< 0x0000004e      jbe 0x7a
|  |||:|`-> 0x00000050      mov ecx, dword [ebx + 0x58c]
|  |||:|    0x00000056      test ecx, ecx
|  |||`===< 0x00000058      jne 0x10
|  ||| |    0x0000005a      add esi, 1
|  ||| |    0x0000005d      mov edx, dword [ebx + 0x208]
|  ||| |    0x00000063      mov eax, dword [edx]
|  ||| |    0x00000065      mov edx, dword [eax + 0x14]
RUN

NAME=reflines offset 2 (ascii)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|       ,=< 0x000113bd      je 0x1144e
|       |   0x000113c3      mov esi, 0x2f                              ; '/' ; int c
|       |   0x000113c8      call sym.imp.strrchr                       ; char *strrchr(const char *s, int c)
|       |   0x000113cd      test rax, rax
|      ,==< 0x000113d0      je 0x11424
|      ||   0x000113d2      lea rdx, [rax + 1]
|      ||   0x000113d6      mov rcx, rdx
|      ||   0x000113d9      sub rcx, rbx
|      ||   0x000113dc      cmp rcx, 6
|     ,===< 0x000113e0      jle 0x11424
|     |||   0x000113e2      lea rsi, [rax - 6]
|     |||   0x000113e6      mov ecx, 7
|     |||   0x000113eb      lea rdi, [rip + 0x7ebb]                    ; str..libs ; 0x192ad ; "/.libs/"
|     |||   0x000113f2      repe cmpsb byte [rsi], byte ptr [rdi]
|    ,====< 0x000113f4      jne 0x11424
|    ||||   0x000113f6      mov ecx, 3
|    ||||   0x000113fb      mov rsi, rdx
|    ||||   0x000113fe      mov rbx, rdx
|    ||||   0x00011401      lea rdi, [rip + 0x7ead]                    ; "lt-" ; 0x192b5
|    ||||   0x00011408      repe cmpsb byte [rsi], byte ptr [rdi]
|    ||||   0x0001140a      seta sil
|    ||||   0x0001140e      setb cl
|    ||||   0x00011411      cmp sil, cl
|   ,=====< 0x00011414      jne 0x11424
|   |||||   0x00011416      lea rbx, [rax + 4]
|   |||||   0x0001141a      mov rax, qword [rip + 0xdeaf]              ; reloc.program_invocation_short_name ; [0x1f2d0:8]=0
|   |||||   0x00011421      mov qword [rax], rbx
|   |||||   ; CODE XREFS from fcn.00011390 (0x113d0, 0x113e0, 0x113f4, 0x11414)
|   ````--> 0x00011424      mov rax, qword [rip + 0xde3d]              ; [0x1f268:8]=0x21680
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
s $S
aaa >/dev/null
s 0x000113bd
pd 28
EOF
RUN

NAME=reflines offset 3 (ascii)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|           0x00003ca6      cmp eax, 2
|       ,=< 0x00003ca9      je 0x45ec
|       |   0x00003caf      cmp eax, 3
|      ,==< 0x00003cb2      je 0x3ce3
|      ||   0x00003cb4      sub eax, 1
|     ,===< 0x00003cb7      je 0x3cbe
|     |||   ; CODE XREF from main (0x58bc)
|     |||   0x00003cb9      call sym.imp.abort                         ; void abort(void)
|     |||   ; CODE XREF from main (0x3cb7)
|     `---> 0x00003cbe      mov edi, 1                                 ; int fd
|      ||   0x00003cc3      call sym.imp.isatty                        ; int isatty(int fd)
|      ||   0x00003cc8      test eax, eax
|     ,===< 0x00003cca      je 0x4c2e
|     |||   0x00003cd0      mov dword [rip + 0x1d626], 2               ; [0x21300:4]=0
|     |||   0x00003cda      mov byte [rip + 0x1d33f], 1                ; [0x21020:1]=0
|    ,====< 0x00003ce1      jmp 0x3cf9
|    ||||   ; CODE XREF from main (0x3cb2)
|    ||`--> 0x00003ce3      mov esi, 5
|    || |   0x00003ce8      xor edi, edi
|    || |   0x00003cea      mov dword [rip + 0x1d60c], 0               ; [0x21300:4]=0
|    || |   0x00003cf4      call fcn.00012740
|    || |   ; CODE XREFS from main (0x3ce1, 0x4602, 0x4c38)
|    `----> 0x00003cf9      lea rdi, [rip + 0x14fb4]                   ; str.QUOTING_STYLE ; 0x18cb4 ; "QUOTING_STYLE" ; const char *name
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
s $S
aaa >/dev/null
s 0x00003ca6
pd 19
EOF
RUN

NAME=reflines offset 3 (ascii + wide)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|           0x00003ca6      cmp eax, 2
|      ,==< 0x00003ca9      je 0x45ec
|      |    0x00003caf      cmp eax, 3
|    ,====< 0x00003cb2      je 0x3ce3
|    | |    0x00003cb4      sub eax, 1
|  ,======< 0x00003cb7      je 0x3cbe
|  | | |    ; CODE XREF from main (0x58bc)
|  | | |    0x00003cb9      call sym.imp.abort                         ; void abort(void)
|  | | |    ; CODE XREF from main (0x3cb7)
|  `------> 0x00003cbe      mov edi, 1                                 ; int fd
|    | |    0x00003cc3      call sym.imp.isatty                        ; int isatty(int fd)
|    | |    0x00003cc8      test eax, eax
|  ,======< 0x00003cca      je 0x4c2e
|  | | |    0x00003cd0      mov dword [rip + 0x1d626], 2               ; [0x21300:4]=0
|  | | |    0x00003cda      mov byte [rip + 0x1d33f], 1                ; [0x21020:1]=0
| ========< 0x00003ce1      jmp 0x3cf9
|  | | |    ; CODE XREF from main (0x3cb2)
|  | `----> 0x00003ce3      mov esi, 5
|  |   |    0x00003ce8      xor edi, edi
|  |   |    0x00003cea      mov dword [rip + 0x1d60c], 0               ; [0x21300:4]=0
|  |   |    0x00003cf4      call fcn.00012740
|  |   |    ; CODE XREFS from main (0x3ce1, 0x4602, 0x4c38)
| --------> 0x00003cf9      lea rdi, [rip + 0x14fb4]                   ; str.QUOTING_STYLE ; 0x18cb4 ; "QUOTING_STYLE" ; const char *name
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
e asm.lines.wide=true
s $S
aaa >/dev/null
s 0x00003ca6
pd 19
EOF
RUN

NAME=reflines offset 4 (ascii + wide)
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
|           0x00003ca6      cmp eax, 2
|      ,==< 0x00003ca9      je 0x45ec
|      |    0x00003caf      cmp eax, 3
|    ,====< 0x00003cb2      je 0x3ce3
|    | |    0x00003cb4      sub eax, 1
|  ,======< 0x00003cb7      je 0x3cbe
|  | | |    ; CODE XREF from main (0x58bc)
|  | | |    0x00003cb9      call sym.imp.abort                         ; void abort(void)
|  | | |    ; CODE XREF from main (0x3cb7)
|  `------> 0x00003cbe      mov edi, 1                                 ; int fd
|    | |    0x00003cc3      call sym.imp.isatty                        ; int isatty(int fd)
|    | |    0x00003cc8      test eax, eax
|  ,======< 0x00003cca      je 0x4c2e
|  | | |    0x00003cd0      mov dword [rip + 0x1d626], 2               ; [0x21300:4]=0
|  | | |    0x00003cda      mov byte [rip + 0x1d33f], 1                ; [0x21020:1]=0
| ========< 0x00003ce1      jmp 0x3cf9
|  | | |    ; CODE XREF from main (0x3cb2)
|  | `----> 0x00003ce3      mov esi, 5
|  |   |    0x00003ce8      xor edi, edi
|  |   |    0x00003cea      mov dword [rip + 0x1d60c], 0               ; [0x21300:4]=0
|  |   |    0x00003cf4      call fcn.00012740
|  |   |    ; CODE XREFS from main (0x3ce1, 0x4602, 0x4c38)
| --------> 0x00003cf9      lea rdi, [rip + 0x14fb4]                   ; str.QUOTING_STYLE ; 0x18cb4 ; "QUOTING_STYLE" ; const char *name
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
e asm.lines.wide=true
aaa >/dev/null
s 0x00003ca6
pd 19
EOF
RUN

NAME=reflines in noreturn
FILE=../bins/elf/analysis/ls-alxchk
EXPECT=<<EOF
/ (fcn) fcn.00012740 76
|   fcn.00012740 (int arg2);
|           ; var int var_8h @ rbp-0x8
|           ; arg int arg2 @ rsi
|           0x00012740      push rbp
|           0x00012741      mov rbp, rsp
|           0x00012744      sub rsp, 0x1030
|           0x0001274b      or qword [rsp], 0
|           0x00012750      add rsp, 0x1020
|           0x00012757      mov rax, qword fs:[0x28]
|           0x00012760      mov qword [var_8h], rax
|           0x00012764      xor eax, eax
|           0x00012766      lea rax, [rip + 0xf033]
|           0x0001276d      test rdi, rdi
|           0x00012770      cmovne rax, rdi
|           0x00012774      mov dword [rax], esi
|           0x00012776      mov rax, qword [var_8h]
|           0x0001277a      xor rax, qword fs:[0x28]
|      ,==< 0x00012783      jne 0x12787
|      |    0x00012785      leave
|      |    0x00012786      ret
\      `--> 0x00012787      call sym.imp.__stack_chk_fail
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.bytes=false
e asm.leahints=false
e scr.utf8=false
e scr.color=false
e asm.lines.wide=true
e asm.comments=0
aaa >/dev/null
s 0x00012740
pdf
EOF
RUN

NAME=‚Åù and XREF cmt
FILE=../bins/elf/strenc-ctrlchars
EXPECT=<<EOF

‚îå (fcn) sym.imp.puts 6
‚îÇ   int sym.imp.puts (const char *s);
‚îÇ       ‚ïé   ; CALL XREF from sym.main (0x400406)
‚îî       ‚ïé   0x004003f0      jmp qword reloc.puts                       ; [0x601018:8]=0x4003f6
        ‚ïé   0x004003f6      push 0
        ‚îî‚îÄ< 0x004003fb      jmp 0x4003e0
EOF
CMDS=<<EOF
e scr.utf8=true
e asm.bytes=false
s main
af
s sym.imp.puts
?e
pd 3
EOF
RUN

NAME=stackptr
FILE=../bins/mach0/mac-ls
EXPECT=<<EOF
104
8
48-
40-
32-
24-
16-
8-
EOF
CMDS=<<EOF
s 0x1000039b6
af
e asm.lines.bb=false
e asm.lines.fcn=false
e asm.stackptr=true
pdr~0x100003b27[1]
pdf~0x100003b27[1]
pdr~0x100003b3d[1]
pdr~0x100003b3e[1]
pdr~0x100003b40[1]
pdr~0x100003b42[1]
pdr~0x100003b44[1]
pdr~0x100003b46[1]
EOF
RUN

NAME=auto string memory reference (iopa)
FILE=malloc://8096
EXPECT=<<EOF
  ; [0x1048:8]=0x500 "Hello"
  0x00000000      mov rsi, qword [rip + 0x1041]
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.arch = x86
e asm.bits=64
e scr.color = false
e io.va=0
e asm.lines.bb=0
e asm.bytes=0
e asm.cmt.right=10
wx 488b3541100000
wv8 0x500 @ 0x1048
w Hello @ 0x500
pd 1
EOF
RUN

NAME=auto string memory reference (io.va)
FILE=malloc://8096
EXPECT=<<EOF
  ; [0x1048:8]=0x500 "Hello"
  0x00000000      mov rsi, qword [rip + 0x1041]
EOF
CMDS=<<EOF
e asm.relsub=false
e asm.arch = x86
e asm.bits=64
e scr.color = false
e io.va=1
e asm.lines.bb=0
e asm.bytes=0
e asm.cmt.right=10
wx 488b3541100000
wv8 0x500 @ 0x1048
w Hello @ 0x500
pd 1
EOF
RUN

NAME=no string on jmp
FILE=malloc://8096
EXPECT=<<EOF
        ,=< 0x00000000      e9fb000000     jmp 0x100
EOF
CMDS=<<EOF
e asm.arch=x86
e asm.bits=32
e emu.str=true
wa jmp 0x100
w hello @ 0x100
pd 1
EOF
RUN

NAME=no string on cbz
FILE=malloc://8096
EXPECT=<<EOF
            0x00000000      15008052       movz w21, 0
        ,=< 0x00000004      b5000034       cbz w21, 0x18               ; likely
EOF
CMDS=<<EOF
e asm.arch=arm
e asm.bits=64
e cfg.bigendian=false
e emu.str=true
wv 0x52800015
wv 0x340000b5 @ 4
w hello @ 0x18
pd 2
EOF
RUN

NAME=No function
FILE=malloc://0x50
EXPECT=<<EOF
EOF
CMDS=<<EOF
aftm
EOF
RUN

NAME=Basic type Matching
FILE=../bins/elf/analysis/x86-helloworld-gcc
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
s sym.main
aa
aei
aeim
td int puts(char *s);
aft
s 0x08048409
pd 1~char *s?
EOF
RUN

NAME=call not function
FILE=../bins/pe/crackme0x00.exe
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
aa
s sym._main
aei
aeim
td int strcmp(char *s1, char *s2);
tk func.strcmp.cc=stdcall
aft
s 0x00401368
pd 1~char *s1?
s 0x00401370
pd 1~char *s2?
EOF
RUN

NAME=1: Wrong calling convention
FILE=../bins/pe/crackme0x00.exe
EXPECT=<<EOF
EOF
CMDS=<<EOF
s entry0
af
tk CRTStartup=func
tk func.CRTStartup.args=1
tk func.CRTStartup.arg0= int,who_cares
tk func.CRTStartup.cc=THE_CC_THAT_NEVER_EXISTED
tk func.CRTStartup.ret=eax
aei
aeim
aftm
EOF
RUN

NAME=2: Wrong calling convention
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
int category
int fd
unsigned long request
EOF
CMDS=<<EOF
s entry0
aaa
afta
Ct. @ 0x100001413
Ct. @ 0x10000145b
Ct. @ 0x100001460
EOF
RUN

NAME=Function definition
FILE=../bins/elf/arm1.bin
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
afr @ main
s 0x000082cc
pd 1~?*xmalloc
EOF
RUN

NAME=Function definition (autorename)
FILE=../bins/pe/hello-mingw32
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
aaa
s 0x00401255
pd 1~?ExitProcess(UINT
EOF
RUN

NAME=Function definition
FILE=../bins/elf/ioli/crackme0x00
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
aaa
s 0x08048469
pd 1~?strcmp(const
EOF
RUN

NAME=afvt
FILE=../bins/mach0/arg
EXPECT=<<EOF
var int var_14h @ rbp-0x14
var int var_10h @ rbp-0x10
var int var_8h @ rbp-0x8
arg int arg1 @ rdi
arg int arg2 @ rsi
EOF
CMDS=<<EOF
s sym._call
af
afv
EOF
RUN

NAME=afvt
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var char var_30h @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvt var_30h char
afv~var_30h
EOF
RUN

NAME=afvn
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var int mylocal @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvn mylocal var_30h
afv~mylocal
EOF
RUN

NAME=afvn + afvn
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var int var_30h @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvn mylocal var_30h
afvn var_30h mylocal
afv~var_30h
EOF
RUN

NAME=afvt + afvn
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var char mylocal @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvn mylocal var_30h
afvt mylocal char
afv~mylocal
EOF
RUN

NAME=afvn + afvt
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var char mylocal @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvt var_30h char
afvn mylocal var_30h
afv~mylocal
EOF
RUN

NAME=afvt + afvt
FILE=../bins/mach0/macho
EXPECT=<<EOF
var int var_30h @ rbp-0x30
var int var_30h @ rbp-0x30
EOF
CMDS=<<EOF
s 0x100000b60
af
afv~var_30h
afvt var_30h char
afvt var_30h int
afv~var_30h
EOF
RUN

NAME=afva for esp based vars
FILE=malloc://1024
EXPECT=<<EOF
/ (fcn) fcn.00000000 89
|           ; var int var_4h @ esp+0x4
|           ; var int var_8h @ esp+0x8
|           ; var int var_ch @ esp+0xc
|           ; arg int arg_14h @ esp+0x14
|           ; arg int arg_18h @ esp+0x18
|           ; arg int arg_1ch @ esp+0x1c
|           ; arg int arg_20h @ esp+0x20
|           ; arg int arg_28h @ esp+0x28
|           ; arg int arg_2ch @ esp+0x2c
|           0x00000000      83ec10         sub esp, 0x10
|           0x00000003      8b442418       mov eax, dword [arg_18h]
|           0x00000007      99             cdq
|           0x00000008      f77c241c       idiv dword [arg_1ch]
|           0x0000000c      8b442414       mov eax, dword [arg_14h]
|           0x00000010      01d0           add eax, edx
|           0x00000012      8944240c       mov dword [var_ch], eax
|           0x00000016      8b442420       mov eax, dword [arg_20h]
|           0x0000001a      99             cdq
|           0x0000001b      f77c2428       idiv dword [arg_28h]
|           0x0000001f      8b44240c       mov eax, dword [var_ch]
|           0x00000023      01d0           add eax, edx
|           0x00000025      89442408       mov dword [var_8h], eax
|           0x00000029      8b542414       mov edx, dword [arg_14h]
|           0x0000002d      8b44240c       mov eax, dword [var_ch]
|           0x00000031      8d0c02         lea ecx, [edx + eax]
|           0x00000034      8b44242c       mov eax, dword [arg_2ch]
|           0x00000038      99             cdq
|           0x00000039      f7f9           idiv ecx
|           0x0000003b      8b442408       mov eax, dword [var_8h]
|           0x0000003f      01d0           add eax, edx
|           0x00000041      89442404       mov dword [var_4h], eax
|           0x00000045      8b54240c       mov edx, dword [var_ch]
|           0x00000049      8b442408       mov eax, dword [var_8h]
|           0x0000004d      01c2           add edx, eax
|           0x0000004f      8b442404       mov eax, dword [var_4h]
|           0x00000053      01d0           add eax, edx
|           0x00000055      83c410         add esp, 0x10
\           0x00000058      c3             ret
EOF
CMDS=<<EOF
e asm.bits=32
e asm.arch = x86
e anal.arch = x86
e asm.calls=false
wx 83ec108b44241899f77c241c8b44241401d08944240c8b44242099f77c24288b44240c01d0894424088b5424148b44240c8d0c028b44242c99f7f98b44240801d0894424048b54240c8b44240801c28b44240401d083c410c38d4c240483e4f0ff71fc5589e55183ec046a076a066a056a046a036a026a01e883ffffff83c41c83ec08506844850408e847feffff83c410b8000000008b4dfcc98d61fcc36690669066909055575653e887feffff81c3371b000083ec0c8b6c24208db30cffffffe8d3fdffff8d8308ffffff29c6c1fe0285f6742531ff8db60000000083ec04ff74242cff74242c55ff94bb08ffffff83c70183c41039f775e383c40c5b5e5f
e asm.bits=32
e asm.comments=false
aa
afva
pdf
EOF
RUN

NAME=afva for fastcall with no esp vars
FILE=../bins/elf/analysis/fast
EXPECT=<<EOF
fastcall
/ (fcn) sym.fastcaslled 59
|   sym.fastcaslled (int arg2, int arg1, int arg_8h, int arg_ch);
|           ; var int var_20h @ ebp-0x20
|           ; var int var_1ch @ ebp-0x1c
|           ; var int var_10h @ ebp-0x10
|           ; var int var_ch @ ebp-0xc
|           ; arg int arg_8h @ ebp+0x8
|           ; arg int arg_ch @ ebp+0xc
|           ; arg int arg2 @ edx
|           ; arg int arg1 @ ecx
|           ; CALL XREF from sym.main (0x80484c7)
|           0x0804841b      55             push ebp
|           0x0804841c      89e5           mov ebp, esp
|           0x0804841e      83ec28         sub esp, 0x28               ; '('
|           0x08048421      894de4         mov dword [var_1ch], ecx    ; arg1
|           0x08048424      8955e0         mov dword [var_20h], edx    ; arg2
|           0x08048427      8b55e4         mov edx, dword [var_1ch]
|           0x0804842a      8b45e0         mov eax, dword [var_20h]
|           0x0804842d      01d0           add eax, edx
|           0x0804842f      8945f4         mov dword [var_ch], eax
|           0x08048432      8b45e0         mov eax, dword [var_20h]
|           0x08048435      2b450c         sub eax, dword [arg_ch]
|           0x08048438      8945f0         mov dword [var_10h], eax
|           0x0804843b      ff7508         push dword [arg_8h]
|           0x0804843e      ff75f0         push dword [var_10h]
|           0x08048441      ff75f4         push dword [var_ch]
|           0x08048444      6874850408     push str.i__i__i            ; 0x8048574 ; "%i %i %i\n"
|           0x08048449      e8a2feffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804844e      83c410         add esp, 0x10
|           0x08048451      90             nop
|           0x08048452      c9             leave
\           0x08048453      c20800         ret 8
EOF
CMDS=<<EOF
aa
s sym.fastcaslled
afc fastcall
afc
afva
pdf
EOF
RUN

NAME=afva for cdecl/stdcall with no esp vars
FILE=../bins/elf/analysis/fast
EXPECT=<<EOF
cdecl
/ (fcn) sym.nonfastcaslled 51
|           ; var int var_10h @ ebp-0x10
|           ; var int var_ch @ ebp-0xc
|           ; arg int arg_8h @ ebp+0x8
|           ; arg int arg_ch @ ebp+0xc
|           ; arg int arg_10h @ ebp+0x10
|           ; arg int arg_14h @ ebp+0x14
|           ; CALL XREF from sym.main (0x80484db)
|           0x08048456      55             push ebp
|           0x08048457      89e5           mov ebp, esp
|           0x08048459      83ec18         sub esp, 0x18
|           0x0804845c      8b5508         mov edx, dword [arg_8h]     ; [0x8:4]=-1 ; 8
|           0x0804845f      8b450c         mov eax, dword [arg_ch]     ; [0xc:4]=-1 ; 12
|           0x08048462      01d0           add eax, edx
|           0x08048464      8945f4         mov dword [var_ch], eax
|           0x08048467      8b450c         mov eax, dword [arg_ch]     ; [0xc:4]=-1 ; 12
|           0x0804846a      2b4514         sub eax, dword [arg_14h]
|           0x0804846d      8945f0         mov dword [var_10h], eax
|           0x08048470      ff7510         push dword [arg_10h]
|           0x08048473      ff75f0         push dword [var_10h]
|           0x08048476      ff75f4         push dword [var_ch]
|           0x08048479      6874850408     push str.i__i__i            ; 0x8048574 ; "%i %i %i\n"
|           0x0804847e      e86dfeffff     call sym.imp.printf
|           0x08048483      83c410         add esp, 0x10
|           0x08048486      90             nop
|           0x08048487      c9             leave
\           0x08048488      c3             ret
EOF
CMDS=<<EOF
e asm.calls=false
aa
s sym.nonfastcaslled
afc
afva
pdf
EOF
RUN

NAME=anal vars crash
FILE=-
EXPECT=<<EOF
EOF
CMDS=<<EOF
af
afvr-*
afvr-*
EOF
RUN

NAME=anal vars crash 2
FILE=-
EXPECT=<<EOF
/ (fcn) fcn.00000000 62
|           ; var int my_local @ rbp-0x18
|           ; arg int arg1 @ rdi
|           0x00000000      0000           add byte [rax], al
EOF
CMDS=<<EOF
e asm.bits=64
e asm.arch = x86
e anal.arch = x86
e asm.calls=false
wx 554889e5534881ec3810000048830c24004881c42010000064488b042528000000488945e831c04885ff4889fb909090909090c3 @ 10
aa
afvn new_1 old_1
afvn my_local var_18h
pd 1
EOF
RUN

NAME=afvb & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvn ImageHandle arg_8h
afvn SystemTable arg_ch
afvb~?ImageHandle
afvb~?SystemTable
EOF
RUN

NAME=afvb* & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvn ImageHandle arg_8h
afvn SystemTable arg_ch
afvb*~?ImageHandle
afvb*~?SystemTable
EOF
RUN

NAME=afvb idx... & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
afvb 8 ImageHandle blah @ 0x10002d8d
EOF
CMDS=<<EOF
af
afvb 8 ImageHandle blah @ 0x10002d8d
afvb*~ImageHandle
EOF
RUN

NAME=afvbj
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
EOF
CMDS=<<EOF
af
afvb 8 ImageHandle blah @ 0x10002d8d
afvbj~?ImageHandle
EOF
RUN

NAME=afvb-ArgName
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
0
EOF
CMDS=<<EOF
af
afvb 8 ImageHandle blah @ 0x10002d8d
afvb-ImageHandle
afvb~?ImageHandle
EOF
RUN

NAME=afvr & afvn
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvr esi myreg int @ 0x10002d8d
afvr~?myreg
afvn blah myreg
afvr~?blah
EOF
RUN

NAME=afvr idx & afvr*
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
1
1
EOF
CMDS=<<EOF
af
afvr esi myreg int @ 0x10002d8d
afvr*~?myreg
afvr*~?int
EOF
RUN

NAME=afvr-name
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
0
EOF
CMDS=<<EOF
af
afvr esi myreg int @ 0x10002d8d
afvr-myreg
afvr~?myreg
EOF
RUN

NAME=afvb-* afvr-*
FILE=../bins/efi/bootia32.efi
EXPECT=<<EOF
0
0
EOF
CMDS=<<EOF
af
afvb-*
afvr-*
afvb~?
afvr~?
EOF
RUN

NAME=anal vars count
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
13
EOF
CMDS=<<EOF
af
afvb~?
EOF
RUN

NAME=anal vars retype
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
var char var_30h @ rbp-0x30
EOF
CMDS=<<EOF
af
afvt var_30h char
afvb~_30h
EOF
RUN

NAME=anal vars rename
FILE=../bins/mach0/ls-osx-x86_64
EXPECT=<<EOF
var int newname @ rbp-0x30
EOF
CMDS=<<EOF
af
afvn newname var_30h
afvb~newname
EOF
RUN

NAME=vars commenting
FILE=malloc://1024
EXPECT=<<EOF
|           ; arg int var_8h @ rbp+0x8    ; comment
EOF
CMDS=<<EOF
af
afvb 8 var_8h int
Cvb 0x8 comment
pd1~comment
EOF
RUN

NAME=vars display in debugger
FILE=../bins/elf/analysis/fast
EXPECT=<<EOF
pxr $w @ebp+0xc
pxr $w @ebp-0x10
EOF
CMDS=<<EOF
aa
s 0x0804843b
afvd arg_ch
afvd var_10h
EOF
RUN

NAME=afvR and afvW test
FILE=../bins/elf/crackme0x05
EXPECT=<<EOF

   var_78h  0x8048577,0x804858a
    var_4h  
   var_78h  
    var_4h  0x804857a
EOF
CMDS=<<EOF
aa
s main
?e
afvR
afvW
EOF
RUN

NAME=axt avr
FILE=../bins/firmware/main.avr
EXPECT=<<EOF
            ; DATA XREF from str.hello ()
            0x00000260      80e0           ldi r24, 0x00
EOF
CMDS=<<EOF
f str.hello 12 @ 0x276
Csa 12 @ str.hello
axd 0x260 @ str.hello
pd 1 @ 0x260
EOF
RUN

NAME=axt capstone x86
FILE=../bins/elf/analysis/main
EXPECT=<<EOF
sym.main 0x40050a [DATA] mov edi, str.Hello_World
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e scr.color=false
e scr.wheel = false
aa
axt @ str.Hello_World
EOF
RUN

NAME=axt capstone x86: IOLI0
FILE=../bins/elf/ioli/crackme0x00
EXPECT=<<EOF
main 0x804843c [DATA] mov dword [esp], str.Password:
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e scr.color=false
e scr.wheel = false
aa
axt @ str.Password:
EOF
RUN

NAME=axt capstone x86: IOLI7 aa
FILE=../bins/elf/ioli/crackme0x07
EXPECT=<<EOF
fcn.08048524 0x804853d [CALL] call sym.imp.exit
fcn.08048542 0x80485ab [CALL] call sym.imp.exit
fcn.080485b9 0x804866f [CALL] call sym.imp.exit
EOF
CMDS=<<EOF
aaa
axt @ sym.imp.exit
EOF
RUN

NAME=axt capstone x86: IOLI7 aa 2
FILE=../bins/elf/ioli/crackme0x07
EXPECT=<<EOF
fcn.08048524 0x804853d [CALL] call sym.imp.exit
fcn.08048542 0x80485ab [CALL] call sym.imp.exit
fcn.080485b9 0x804866f [CALL] call sym.imp.exit
EOF
CMDS=<<EOF
aaaa
axt @ sym.imp.exit
EOF
RUN

NAME=axt respect relsub
FILE=../bins/pe/ibknoreloc64.exe
EXPECT=<<EOF
entry0 0xffffffffffff100a [CALL] call qword [rip + 0xd8]
entry0 0xffffffffffff100a [CALL] call qword sym.imp.msvcrt.dll_printf
EOF
CMDS=<<EOF
aaa
e asm.relsub=false
axt @ sym.imp.msvcrt.dll_printf
e asm.relsub=true
axt @ sym.imp.msvcrt.dll_printf
EOF
RUN

NAME=ax-
FILE=-
EXPECT=<<EOF
0x00000014 -> 0x0000000a  UNKNOWN
EOF
CMDS=<<EOF
ax 10 20
axq
ax-10 20
axq
EOF
RUN

NAME=ax-@
FILE=-
EXPECT=<<EOF
0x00000014 -> 0x0000000a  UNKNOWN
EOF
CMDS=<<EOF
s 20
ax 10
axq
ax-10
axq
EOF
RUN

NAME=ax-*
FILE=-
EXPECT=<<EOF
                                       ? 0x0 ->   UNKNOWN -> 0xa
EOF
CMDS=<<EOF
ax 10
ax
ax-*
ax
EOF
RUN

NAME=axt unknown function
FILE=../bins/pe/lab11.malware
EXPECT=<<EOF
(nofunc) 0x401a1d [CALL] call fcn.00401270
EOF
CMDS=<<EOF
aaa
axt fcn.00401270
EOF
RUN

NAME=axf string ref capstone x86
FILE=../bins/elf/ioli/crackme0x03
EXPECT=<<EOF
sym.test 0x804848a [DATA] mov dword [esp], str.Sdvvzrug_RN
d 0x804848a mov dword [esp], str.Sdvvzrug_RN
EOF
CMDS=<<EOF
e asm.arch = x86
e anal.arch = x86
e scr.color = false
e scr.wheel = false
aa
axt str.Sdvvzrug_RN
axf 0x804848a
EOF
RUN

NAME=x86 ref issue
FILE=-
EXPECT=<<EOF
0x00004434
EOF
CMDS=<<EOF
e asm.bits=64
e asm.arch=x86
wx c7052a44000050000000
ao~^ptr[1]
EOF
RUN

NAME=strings xref issue
FILE=../bins/elf/redpill
EXPECT=<<EOF
main 0x1457 [STRING] lea eax, str.Take_the_Red_Pill
main 0x148e [STRING] lea eax, str.use:_._exploit1_PILL
main 0x14eb [STRING] lea eax, str.Red_Pill__0x50444552
main 0x1502 [STRING] lea eax, str.Your_Pill_0x_08x
main 0x1523 [STRING] lea eax, str.Red_Pill
main 0x1557 [STRING] lea eax, str.fwhibbit
main 0x161d [STRING] lea eax, str.Blue_Pill
EOF
CMDS=<<EOF
e anal.strings=true
aa
aae
axt 0x00001d89
axt 0x00001da0
axt 0x00001db7
axt 0x00001dd1
axt 0x00001de8
axt 0x00001df4
axt 0x00001e09
EOF
RUN

NAME=reference to like mov [0x400000], 0x1234
FILE=../bins/elf/analysis/reference.out
EXPECT=<<EOF
sym.main 0x80483ee [DATA] mov dword obj.a, 0x1337
EOF
CMDS=<<EOF
aaa
axt@0x0804a01c
EOF
RUN

NAME=delete references with ax-
FILE=-
EXPECT=<<EOF
0x00000014 -> 0x0000000a  UNKNOWN
0x00000014 -> 0x0000000a  UNKNOWN
0x00000028 -> 0x0000001e  UNKNOWN
EOF
CMDS=<<EOF
ax 10 20
axq
ax- 10
axq
ax 10 20
ax 30 40
axq
ax-*
axq
EOF
RUN

NAME=reference PIC binary
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
main 0x8048432 [STRING] lea eax, str.Hello_PIC
EOF
CMDS=<<EOF
e anal.strings=true
aa
aae
axt@0x80484e0
EOF
RUN

NAME=strings xref issue without relsub
FILE=../bins/elf/redpill
EXPECT=<<EOF
main 0x1457 [STRING] lea eax, [esi - 0x2277]
main 0x148e [STRING] lea eax, [esi - 0x2260]
main 0x14eb [STRING] lea eax, [esi - 0x2249]
main 0x1502 [STRING] lea eax, [esi - 0x222f]
main 0x1523 [STRING] lea eax, [esi - 0x2218]
main 0x1557 [STRING] lea eax, [esi - 0x220c]
main 0x161d [STRING] lea eax, [esi - 0x21f7]
EOF
CMDS=<<EOF
e anal.strings=true
e asm.relsub=false
aa
aae
axt 0x00001d89
axt 0x00001da0
axt 0x00001db7
axt 0x00001dd1
axt 0x00001de8
axt 0x00001df4
axt 0x00001e09
EOF
RUN

NAME=reference PIC binary without relsub
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
main 0x8048432 [STRING] lea eax, [ebx - 0x1b20]
EOF
CMDS=<<EOF
e anal.strings=true
e asm.relsub=false
aa
aae
axt@0x80484e0
EOF
RUN

NAME=refs on PIC binary disassembly
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
|           0x08048432      8d83e0e4ffff   lea eax, str.Hello_PIC      ; 0x80484e0 ; "Hello PIC!"
EOF
CMDS=<<EOF
e anal.strings=true
aa
aae
pd 1 @ 0x08048432
EOF
RUN

NAME=refs on PIC binary disassembly (color)
FILE=../bins/elf/analysis/xrefpic
EXPECT=<<EOF
[36m|[0m [36m          [0m[32m0x08048432[0m      [37mlea[36m eax[0m,[36m [0m[33mstr.Hello_PIC[0m[36m[0m[0m
EOF
CMDS=<<EOF
e asm.bytes=false
e asm.comments=false
e scr.color=1
e anal.strings=true
aa
aae
pd 1 @ 0x08048432
EOF
RUN

NAME=axs
FILE=-
EXPECT=<<EOF
0x00000000 -> 0x00000010  STRING
EOF
CMDS=<<EOF
axs 0x10
axq
EOF
RUN

NAME=refs with aar
FILE=../bins/elf/crackme
EXPECT=<<EOF
;-- __libc_csu_fini:
; DATA XREF from entry0 (+0xf)
0x00400730      f3c3           ret
; CODE XREF from sym.__do_global_ctors_aux (+0x2d)
0x004007f0      4883eb08       sub rbx, 8
;-- __do_global_dtors_aux:
; CALL XREF from section..fini (+0x4)
0x00400610      55             push rbp
EOF
CMDS=<<EOF
e asm.lines.bb=false
e asm.lines.fcn=false
aar
pd 1 @0x400730
pd 1 @0x4007f0
pd 1 @0x400610
EOF
RUN

NAME=refs with afr
FILE=../bins/elf/crackme
EXPECT=<<EOF
(fcn) sym.__libc_csu_fini 2
  sym.__libc_csu_fini ();
; DATA XREF from entry0 (0x4005cf)
0x00400730      f3c3           ret
; CODE XREF from sym.__do_global_ctors_aux (0x4007fd)
0x004007f0      4883eb08       sub rbx, 8
(fcn) sym.__do_global_dtors_aux 100
  sym.__do_global_dtors_aux ();
; CALL XREF from sym._fini (0x40080c)
0x00400610      55             push rbp
EOF
CMDS=<<EOF
e asm.lines.bb=false
e asm.lines.fcn=false
e anal.cjmpref=true
aa
afr
pd 1 @0x400730
pd 1 @0x4007f0
pd 1 @0x400610
EOF
RUN

NAME=cjmp data refs with aar
FILE=malloc://10000
EXPECT=<<EOF
; DATA XREF from unk ()
0x1000002e      00             nop
EOF
CMDS=<<EOF
e asm.arch=8051
e asm.lines.bb=false
e asm.lines.fcn=false
wx 307401000022
aar
pd 1 @_idata+0x2e
EOF
RUN

NAME=cjmp data refs with afr
FILE=malloc://10000
EXPECT=<<EOF
; DATA XREF from fcn.00000000 ()
0x1000002e      00             nop
EOF
CMDS=<<EOF
e asm.arch=8051
e asm.lines.bb=false
e asm.lines.fcn=false
wx 307401000022
aa
afr
pd 1 @_idata+0x2e
EOF
RUN

NAME=xtensa stackframe
FILE=malloc://512
EXPECT=<<EOF
var int var_4h @ a1+0x4
var int var_8h @ a1+0x8
var int var_ch @ a1+0xc
EOF
CMDS=<<EOF
e asm.arch=xtensa
e asm.bits=32
wx 12c1f0d91140d382c9213d0d093101f5ebc00000cd028c820c034d0d0112e4c0000008312d0cd811c82112c1100df0
af
afvs
EOF
RUN

NAME=xrefs and overlapping basic blocks
FILE=../bins/elf/analysis/ls-linux-x86_64-zlul
CMDS=<<EXPECT
aaa
axt main
EXPECT=<<RUN
entry0 0x40488d [DATA] mov rdi, main
RUN

NAME=unique function names
FILE=../bins/elf/bash
CMDS=<<EXPECT
aaa
f~strlen~390
EXPECT=''
RUN

NAME=no function split without overlapping blocks
FILE=../bins/elf/libc.so.6
CMDS=<<EXPECT
aac
s 0x2254d
agf~invalid
echo end
EXPECT=end
RUN

NAME=noreturn of reloc-functions
FILE=../bins/elf/ls
CMDS=<<EXPECT
aaa
afbr 0x80b0
EXPECT=<<RUN
0x000081cb
0x00008237
RUN
